Here is complete, optimized MicroPython code for a line-following robot with the described wiring using Raspberry Pi Pico and a motor driver. This code is meant to ensure both **speed and accuracy**, using a simple proportional controller based on the IR sensor readings. The layout and pin assignments match your connections.

***

### MicroPython Code for Line Following Robot

```python
# Import necessary libraries
from machine import Pin, PWM
import utime

# -------- Pin Assignments --------
# IR Sensors
IR_PINS = [2, 3, 4, 5, 6]  # GP2 (Leftmost) -> IR1, GP3 -> IR2, ..., GP6 (Rightmost) -> IR5

# Motor Driver Pins
AIN1 = Pin(10, Pin.OUT)
AIN2 = Pin(11, Pin.OUT)
PWMA = PWM(Pin(12))
BIN1 = Pin(13, Pin.OUT)
BIN2 = Pin(14, Pin.OUT)
PWMB = PWM(Pin(15))

# Motor Driver Standby
STBY = Pin(36, Pin.OUT)  # 3V3(OUT) for standby

# Constants
MAX_SPEED = 65000        # Max PWM value (~ Duty cycle 100%) for speed (16-bit, for RP Pico PWM)
BASE_SPEED = 40000       # Normal running speed
CORRECTION = 25000       # Speed correction amount

# IR Sensor Weighting for PID (Proportional only implemented)
sensor_weights = [-2, -1, 0, 1, 2]  # Leftmost to rightmost

# -------- Functions --------

def setup_pwm(pwm_pin):
    pwm_pin.freq(1000)
    pwm_pin.duty_u16(0)

def set_motor(left, right):
    # left, right: values from -MAX_SPEED to +MAX_SPEED
    
    # Left motor control
    if left > 0:
        AIN1.value(1)
        AIN2.value(0)
        PWMA.duty_u16(min(int(left), MAX_SPEED))
    elif left < 0:
        AIN1.value(0)
        AIN2.value(1)
        PWMA.duty_u16(min(int(-left), MAX_SPEED))
    else:
        PWMA.duty_u16(0)

    # Right motor control
    if right > 0:
        BIN1.value(1)
        BIN2.value(0)
        PWMB.duty_u16(min(int(right), MAX_SPEED))
    elif right < 0:
        BIN1.value(0)
        BIN2.value(1)
        PWMB.duty_u16(min(int(-right), MAX_SPEED))
    else:
        PWMB.duty_u16(0)

def read_ir_array():
    readings = []
    for pin in IR_PINS:
        readings.append(Pin(pin, Pin.IN).value())
    return readings

def get_error(ir_vals):
    # Returns position error using weighted average
    numerator = 0
    denominator = 0
    for i, val in enumerate(ir_vals):
        if val == 0:
            # 0 means black line detected (depending on sensor logic; adjust if reversed)
            numerator += sensor_weights[i]
            denominator += 1
    if denominator == 0:
        return 0  # No line found, drive straight or take corrective action
    return numerator / denominator

def line_follow():
    while True:
        ir_vals = read_ir_array()
        error = get_error(ir_vals)
        
        # Proportional control: adjust speed based on line position error
        left_speed = BASE_SPEED + CORRECTION * (-error)
        right_speed = BASE_SPEED + CORRECTION * (error)
        
        # Limit the speed
        left_speed = max(0, min(MAX_SPEED, left_speed))
        right_speed = max(0, min(MAX_SPEED, right_speed))
        
        set_motor(left_speed, right_speed)
        utime.sleep_ms(10)

# -------- Main --------

# Initialize all PWM
setup_pwm(PWMA)
setup_pwm(PWMB)
STBY.value(1)  # Take Motor Driver out of standby

print("Line following robot starting!")

# Start line following loop
line_follow()
```

***

### Notes and Recommendations

- This code assumes that the IR sensors output **LOW (0)** on black and **HIGH (1)** on white. If inverted, change the `if val == 0:` line to `if val == 1:` in `get_error()`.
- The robot drives both motors forward by default and adjusts speeds to steer. Tune `BASE_SPEED` and `CORRECTION` for your desired speed and responsiveness.
- Emergency handling (e.g., all sensors off-line: lost line) is set to drive straight; customize for your needs.
- For more accuracy, consider adding differential correction (PID) or "last known good" direction memory.

***

This code will make your robot follow a line swiftly and with reasonable accuracy. Adjust constants to suit surface and motor characteristics.
